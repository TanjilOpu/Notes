1. #include <sstream> 
directive includes the String Stream library, which provides classes 
like std::stringstream, std::istringstream, and std::ostringstream to treat strings as I/O streams 
for in-memory formatting, type conversion (e.g., number-to-string and vice-versa), and string parsing.


2. #include<limits>
Common Use: Accessing the maximum and minimum possible values for a given type, 
determining its size, or checking if it's signed.

3. #include<algorithm>
It contains non-member functions that implement common algorithms like sorting, searching, 
modifying, and comparing data sequences.

4.#include<cctype>
certain category type like(ischar,islower,isupper,isdigit)

5
#include<cppconn/driver.h>
#include<cppconn/connection.h>
#include<cppconn/statement.h>            //used for executing SQL queries (like SELECT, INSERT, UPDATE) without parameters.
#include<cppconn/prepared_statement.h>   //Provides sql::PreparedStatement class – lets you write parameterized queries safely.(Prevents SQL injection and is faster for repeated queries.)
#include<cppconn/resultset.h>          //select all form .............
#include<cppconn/exception.h>

driver + connection → connect to MySQL
statement + prepared_statement → send queries
resultset → read query results
exception → catch errors safely


6.string to_upper(string s)
{
	transform(s.begin(), s.end(), s.begin, [](unsigned char c) {
		return toupper(c);
		});
	return s;

transform(...)
This is a standard algorithm from <algorithm>.
It applies a transformation to each element in a range.
Here, it takes:
s.begin() → start of the string
s.end() → end of the string
s.begin() → where to write the result (overwriting original string)
A lambda function to transform each character.


7.
int get_numeric_input(const string &prompt, int default_value, bool allow_zero = true)
{
    int value;
    cout << prompt;
    while (true)
    {
        if (cin >> value)
        {
            if (!allow_zero && value <= 0)
            {
                cout << "Value must be greater than zero. Please enter a valid number (e.g., " << default_value << "): ";
                cin.clear();
                cin.ignore(numeric_limits<streamsize>::max(), '\n');
                continue;
            }
            // CRITICAL: Successful numeric read leaves a newline. We MUST ignore it here.
            cin.ignore(numeric_limits<streamsize>::max(), '\n');
            return value;
        }
        else
        {
            cout << "Invalid input. Please enter a number (e.g., " << default_value << "): ";
            cin.clear();
            cin.ignore(numeric_limits<streamsize>::max(), '\n');
        }
    }
}
This is a C++ function named get_numeric_input designed to robustly read and validate an integer value from the user's input.
It handles two main types of errors: non-numeric input (like letters) and invalid zero/negative values when restricted.

8.
void setup_database(sql::Connection* con)
{
    sql::Statement* stmt = nulptr;
}
sql::Connection* con: It takes one parameter: a pointer to an active database connection.
This connection object (con) is what the function would use to send SQL commands to the MySQL server.
sql::Statement* stmt = nullptr;
This is the entire body of the function.
It declares a pointer named stmt of type sql::Statement. This is the object used to execute SQL commands.
It initializes this pointer to nullptr (a null pointer).

8 9 10 are linked with each other
9.
con->setSchema(DB_NAME) is a method call in C++ using the MySQL Connector/C++ library. 
Its work is to specify the default database (schema) that all subsequent SQL statements will operate on using the given connection.


10.
stmt = con->createStatement();
Work: This line creates a new object designed to handle the execution of simple, non-parameterized SQL commands.
 stmt->execute(create_table_sql);
Work: This line takes the prepared SQL command and sends it to the MySQL server for immediate processing.
execute(...): This method is called to execute any type of SQL command, regardless of whether it returns data (like SELECT)
or modifies the database (like INSERT, UPDATE, DELETE, or in this case, CREATE TABLE).

summary, these two lines allocate a resource (stmt) to package and
execute the CREATE TABLE command contained in the create_table_sql string.

11. delete stmt
You need to call delete stmt; because the sql::Statement object (pointed to by stmt) was created using the con->createStatement() method,
which typically uses the C++ keyword new internally. In C++, when you create an object using new (or a function that allocates memory dynamically,
like createStatement()), you are responsible for freeing that memory using the corresponding delete keyword.
This practice is essential for resource management and preventing memory leaks.

12.
catch (sql::SQLException& e)
{
    cerr << "SQL Error during setup: " << e.what() << endl;
    if (stmt)
        delete stmt;
    throw;
}
Reports the Error. It prints an error message to the standard error stream (cerr), 
including the descriptive text provided by the e.what() method. connection lost, invalid SQL, table already exists

throw:   This ensures that the error is not simply swallowed( gile fela) ; it allows functions higher up the call stack to be informed that
           the database setup failed, typically leading to the termination of the program

13.
        pstm = con->prepareStatement(insert_sql);
The line pstm = con->prepareStatement(insert_sql); is a crucial step in executing database operations using the MySQL Connector/C++ library.
Meaning and Work
This statement means you are preparing a PreparedStatement object to execute a specific SQL command, typically an INSERT statement, in a safe and efficient manner.
1. Meaning (Preparation)
pstm: This is a pointer to an sql::PreparedStatement object.
con: This is a pointer to the active sql::Connection object.
con->prepareStatement(insert_sql): This method is called on the connection object to parse and pre-compile the SQL query (insert_sql) on the database server.
2. Work (Security and Efficiency)
The work of this method is twofold:
Security (Parameterized Queries): The insert_sql string is expected to contain placeholders (usually question marks, ?) instead of actual data values. For example:
SQL
"INSERT INTO users (name, age) VALUES (?, ?)"
The prepareStatement method sends this structure to the database. Later, you will bind the actual data to these placeholders.
This separation of code (the SQL statement) and data prevents SQL injection attacks, as the data is never interpreted as executable code.

14.
        pstm->execute();
            The work of pstm->execute(); is to send the complete SQL command (the pre-compiled structure plus all the bound data values) to the database server for execution.
                   In short: it runs the query (like INSERT or UPDATE) that was prepared by the PreparedStatement object.

15. if (search_address_upper != "ANY" && !search_address_upper.empty())
 {
     query_builder<<"AND UPPER(address) LIKE '%' "<<search_address_upper<< "%'";
 }
AND UPPER(address) LIKE '%MAIN%'
This tells the database to return records where the address column contains the word "main" (or "Main," "mAiN," etc.) anywhere within the string.

16
UPDATE mess_info SET column_name = ? WHERE id = ?
                                      ^        ^
                                index=1   index=2


17.
// SQL DELETE statement using a Prepared Statement
string delete_sql = "DELETE FROM mess_info WHERE id = ?";
pstm = con->prepareStatement(delete_sql);
pstm->setInt(1, mess_id);


explanation: 1️ string delete_sql = "DELETE FROM mess_info WHERE id = ?";
This line defines an SQL command that will delete a record from the table mess_info.
WHERE id = ? means we’re not directly putting the ID in the query yet — instead, the question mark (?) is a placeholder.
This is part of using a Prepared Statement, which helps prevent SQL injection and allows MySQL to optimize query execution.
So the SQL query template looks like:
DELETE FROM mess_info WHERE id = ?
The ? will later be replaced by an actual value.

2️ pstm = con->prepareStatement(delete_sql);
Here, con is a pointer to a MySQL connection object (like a “gateway” to your database).
prepareStatement(delete_sql) tells MySQL:
“Prepare this SQL command for execution, but I’ll give you the exact value later.”
It returns a pointer to a prepared statement object, which we store in pstm.
So now pstm can be used to safely insert values and execute the SQL.

3️ pstm->setInt(1, mess_id);
setInt() sets the first placeholder (?) in the SQL query to an integer value.

1 → means the first ? placeholder.
mess_id → is the C++ variable that holds the ID you want to delete.
If mess_id = 5, then the final SQL sent to MySQL becomes:


18.
        int rows_affected = pstm->executeUpdate();
pstm	Prepared Statement Pointer	A pointer to the object holding the pre-compiled SQL command (like UPDATE or DELETE) 
and the data values (like mess_id).
->executeUpdate()	Execution Method	This method sends the complete SQL command to the MySQL database server and tells it to run. 
It's used for commands that change the database (like INSERT, UPDATE, DELETE), not commands that retrieve data (SELECT).
rows_affected	Return Value	The database returns an integer representing the number of rows that were successfully modified, inserted,
or deleted by the command.
int	Data Type	Declares the variable to store the integer result.

19.
  sql::Statement* stmt = nullptr;
  sql::ResultSet* res = nullptr;
sql::Statement* stmt = nullptr;	Statement Pointer	Used to send simple, direct, non-parameterized SQL commands (like creating a table 
or running a query without user-input filtering).	nullptr (or NULL) means the pointer currently points to nothing.
It's a placeholder until the code calls con->createStatement() to create the actual object.
sql::ResultSet* res = nullptr;	ResultSet Pointer	Used to hold the results (rows and columns of data) returned 
from the database after a successful SELECT query is executed.	nullptr means the pointer currently holds no data. 
It's set after a successful query (e.g., stmt->executeQuery()).

20.        stmt = con->createStatement();
The primary work of con->createStatement() is to create and return a pointer to a new sql::Statement object.
This new Statement object acts as a simple container or executor for sending basic, non-parameterized SQL commands (like CREATE TABLE, DROP TABLE,
or SELECT * FROM table;) directly to the connected database (con).
It's the mechanism you use to run static queries, unlike a PreparedStatement, which is used for dynamic queries with placeholders.

21.    sql::PreparedStatement* pstm = nullptr;
This line declares a pointer named pstm to a sql::PreparedStatement object and initializes it to nullptr.

Work: It creates a placeholder for an object that will later be used to safely and efficiently execute parameterized SQL queries 
(like INSERT, UPDATE, or DELETE) against the database

22.  pstm = con->prepareStatement(insert_sql);

The work of the line pstm = con->prepareStatement(insert_sql); is to prepare a structured SQL command for safe execution.
Part	Role	Explanation
con	Connection Object	The active connection to the MySQL database server.
->prepareStatement()	Method Call	This function sends the SQL string (insert_sql) to the database server. 
The server then parses, compiles, and optimizes the query structure (which contains placeholders like ?).
pstm	Result (Pointer)	The function returns a pointer to a new sql::PreparedStatement object. This object now holds the ready-to-run query template, allowing you to securely bind values to the placeholders (?) before execution
